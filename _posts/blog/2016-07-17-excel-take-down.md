---
layout: post
title: "Excel Take-Down"
modified:
categories: blog
excerpt: "Excel take-down."
tags: [Notes]
image:
  feature: bg\5.jpg
  credit: WeGraphics
  creditlink: http://wegraphics.net/
date: 2016-06-01T14:36:51-04:00
modified: 2016-07-17T21:06:23-04:00
---

视图→冻结窗格→冻结拆分窗格

设置工作表标签的颜色→右击要更改颜色的工作表标签→工作表标签颜色

复制工作表→选中要复制的工作表 按下Ctrl键不放 拖动工作表标签至新表

右击任意工作簿→移动或复制→移动至该表/复制至该表（勾选 建立副本）

选定不连续的单元格→Ctrl+拖动鼠标

* Ctrl+Home 数据区域中第一个单元格
* Ctrl+End   数据区域中最后一个单元格
* Ctrl+Shift+↓ 该单元格所在列下方所有单元格
* Ctrl+Shift+← 该单元格所在行左侧所有单元格

跨越合并：开始→对齐方式→合并后居中 下拉菜单→跨越合并

指对选择的多行多列的单元格进行合并后，只对所选单元格的列进行合并，不对所选单元格的行进行合并。

行高、列宽→格式

当输入的数值长度超过了单元格的长度时，则Excel会默认以科学计数法的形式显示；遇到此种情况时，只需在数值前输入单引号“ ' ”，然后输入数值，这样一来，Excel自动完整显示输入的文本。

输入分数时加上整数部分，例如输入真分数则需要在前面添加0，而输入带分数则在前面添加其对应的整数部分（避免和日期混淆，如2/3）

符号：插入→符号→字体：Wingdings→√

设置显示“0”：设置单元格格式→数字→文本→上标、下标

限制数据范围：数据→数据验证→设置→整数（介于18与40之间），文本长度（等于 11），序列（下拉列表），设置提示信息（输入信息），出错警告

圈释无效数据：选定单元格区域→数据验证→圈释无效数据

快速填充数据：开始→填充→序列

1. 等差序列填充：设置填充步长值与终止值
2. 等比序列填充：步长值，终止值
3. 日期填充：类型：日期，日期单位：工作日（非“日期”，刨除双休）

选择性粘贴：转置粘贴、粘贴为图片

清除：开始→编辑→清除

设置单元格的数字显示格式：开始→数字→格式框下拉→会计专用、日期

自动换行：对齐→文本控制

强制换行：Alt + Enter

文字方向：对齐→文字方向→斜线表头时 -22°

自定义表格样式：开始→样式→套用表格格式→新建表格样式

表格工具→设计→标题行、第一列

页面布局→页面设置→背景

:（冒号） 区域运算符，对于两个引用之间，包括两个引用在内的所有单元格进行引用 A1:B3

,（逗号） 联合运算符，将多个引用合并为一个引用 SUM(A1:B2,A3:A4)

 （空格） 交叉运算符，产生同时属于两个引用的单元格区域的引用 SUM(A4:H4 B3:B8)

若用户只想复制单元格中的数值，而不想连同公式一起复制，可在粘贴选项中选择粘贴“值和数字格式”即可。

公式→显示公式

相对引用的格式是直接用单元格或者单元格区域名。使用相对引用后，系统将会记住建立公式的单元格和被引用的单元格的相对位置关系，在粘贴这个公式时，新的公式单元格和被引用的单元格仍保持这种相对格式。

绝对引用就是指被引用的单元格与引用的单元格的位置关系是绝对的，无论将这个公式粘贴到任何单元格，公式所引用的还是原来单元格的数据。绝对引用的单元格名的行和列前都有“$”符号，即绝对符号。

若$符号在数字前，而字母前没有$符，那么被引用的单元格行的位置是绝对的，列位置是相对的。反之，行的位置是相对的，而列的位置是绝对的。这就是混合引用。

九九乘法表：我们希望第一个乘法的最左列不动（$A）而行跟着变动，希望第二个乘数的最上行不动（$1）而列跟着变动，因此将B2单元格中的公式更改为=$A2*B$1。

用感叹号“！”将工作表引用和单元格引用分开。

    ####!：公式产生的结果或输入的常数太长，当前单元格宽度不够，不能正确地显示出来，将单元格加宽就可以避免这种错误
    #DIV/0!：公式中产生了除数或者分母为0的错误，这时候就要检查：（1）公式中是否引用了空白的单元格或数值为0的单元格作为除数；（2）引用的宏程序是否包含了返回“#DIV/0！”值的宏函数；（3）是否有函数在特定条件下返回“#DIV/0！”错误值
    #N/A：引用的单元格中没有可以使用的数值，在建立数学模型缺少个别数据时，可以在相应的单元格中输入#N/A，以免引用空单元格
    #NAME?：公式中含有不能识别的名字或者字符，这时候就要检查公式中引用的单元格名字是否输入了不正确的字符
    #NULL!：试图为公式中两个不相交的区域指定交叉点，这时候就要检查是否使用了不正确的区域操作符或者不正确的单元格引用
    #NUM!：公式中某个函数的参数不对，这时候就要检查函数的每个参数是否正确
    #REF!：引用中有无效的单元格，移动、复制和删除公式中的引用区域时，应当注意是否破坏了公式中的单元格引用，检查公式中是否有无效的单元格引用
    #VALUE!：在需要数值或者逻辑值的地方输入了文本，检查公式或者函数的数值和参数

追踪应用单元格：引用单元格是指被其他单元格中的公式引用的单元格。

追踪从属单元格：就是用于指明受当前所选单元格值影响的单元格。

公式→错误检查、公式求值

一个函数最多可以嵌套7层。

`=IF(SUM(D2:D5)>=150000, “免费”, 1000)`

当D2:D5单元格区域的总和不小于150000时，则嵌套函数的值为“免费”；当D2:D5单元格区域的总和小于150000时，则嵌套函数的值为“1000”。

#### IF()函数

功能：如果指定条件的计算结果为TRUE，IF函数将返回某个值；如果该条件的计算结果为FALSE，则返回另一个值。

语法：IF(logical_test, [value_if_true], [value_if_false])

参数含义：

* Logical_test 表示判断条件，其结果可能为TRUE或FALSE的任意值或表达式。
* value_if_true 表示计算结果为TRUE时所要返回的值。
* value_if_false 表示计算结果为FALSE时所要返回的值。如果logical_test的计算结果为FALSE，并且省略value_if_false参数（即value_if_true参数后没有逗号），则IF函数返回逻辑值FALSE。如果logical_test的计算结果为FALSE，并且省略value_if_false参数的值（即，在IF函数中，value_if_true参数后没有逗号），则IF函数返回值0（零）。

#### SUMIF()函数

功能：对指定单元格区域中符合指定条件的值求和。

语法：SUMIF(range, criteria, [sum_range])

参数含义：

* range 用于条件计算的单元格区域。每个区域中的单元格都必须是数字或名称、数组或包含数字的引用，空值和文本值将被忽略。
* criteria 用于确定对单元格求和的条件，其形式可以为数字、表达式、单元格引用、文本或函数。
* sum_range 用于指定要求和的实际单元格。如果省略该参数，Excel会对在范围参数中指定的单元格（即应用条件的单元格）求和。

#### COUNTIF()函数

功能：用于统计某个区域内符合指定的单个条件的单元格数量。

语法：COUNTIF(range, criteria)

参数含义：

* range 表示要计数的一个或多个单元格，包括数字或包含数字的名称、数组或引用。空值和文本值将被忽略。
* criteria 定义要进行计数的单元格的数字、表达式、单元格引用或文本字符串。

#### RANK()函数

功能：返回某一列数字的数字排位，数字排位是其相对于列表中其他值的大小。

语法：RANK(number, ref, [order])

参数含义：

* number 指定需找到排位的数值，或者数值所在的单元格。
* ref 指定包含数值的单元格区域或者区域名称，ref区域内的空白单元格或者文	本、逻辑值将被忽略。
* order 指定排序的方式。如果order为0（零）或省略，Excel将基于ref降序排	列；如果order非零，Excel将基于ref升序排列。

#### HLOOKUP()函数

功能：在表格或数值数组的首行查找指定的数值，并在表格或数组中指定行的同一列中返回一个数值。当比较值位于数据表的首行，并且要查找下面给定行中的数据时，可使用函数HLOOKUP。

语法：HLOOKUP(lookup_value, table_array, row_index_num, range_lookup)

参数含义：

* lookup_value 是需要在数据表第一行中进行查找的数值。Lookup_value可以为数值、引用或文本字符串。
* table_array 为需要在其中查找数据的数据表。它通常是对单元格区域或区域名称的引用。
* row_index_num 为table_array中待返回的匹配值的行序号。row_index_num为1	时，返回table_array第一行的数值，row_index_num为2时，返回table_array第二行的数值，以此类推。如果row_index_num小于1，函数HLOOKUP返回错误值#VALUE!；如果row_index_num大于table_array的行数，函数HLOOKUP返回错误值#REF!。
* range_lookup 为一逻辑值，指明函数HLOOKUP查找时是精确匹配，还是近似匹配。如果为TRUE或省略，则返回近似匹配值。也就是说，如果找不到精确匹配值，则返回小于lookup_value的最大数值。如果lookup_value为FALSE，函数HLOOKUP将查找精确匹配值，如果找不到，则返回错误值#N/A。

#### PMT()函数

功能：基于固定利率及等额分期付款方式，返回贷款的每期付款额。

语法：PMT(rate, nper, pv, fv, type)

参数含义：

* rate 为贷款利率。
* nper 为该项贷款的付款总数。
* pv 表示现值，或一系列未来付款的当前值的累积和，也称为本金。
* fv 为未来值，或在最后一次付款后希望得到的现金余额，如果省略fv，则假设其值为零，也就是一笔贷款的未来值为零。
* type 数字0或1，用以指定各期的付款时间是在期初还是期末。当type值为0	或省略时，表示为期末；当type值为1时表示为期初。

* =DATEDIF(A2,TODAY(),”y”) 根据出生年月计算年龄
* =--TEXT(MID(A2,7,8),”0-00-00”) 根据身份证号码提前出生年月
* =IF(MOD(MID(A2,15,3),2),”男”,”女”) 根据身份证号码提取性别
* =RANK.EQ(A2,A$2:A$7) 成绩排名

* A列求和：=SUM(A:A)
* A列最小值：=MIN(A:A)
* A列最大值：=MAX(A:A)
* A列平均值：=AVERAGE(A:A)
* A列数值个数：=COUNT(A:A)